{"ast":null,"code":"// Regular expression used for basic parsing of the uuid.\nvar pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n/**\n * Unparses a UUID buffer to a string. From node-uuid:\n * https://github.com/defunctzombie/node-uuid/blob/master/uuid.js\n *\n * Copyright (c) 2010-2012 Robert Kieffer\n * MIT License - http://opensource.org/licenses/mit-license.php\n *\n * @param  {Buffer} buf\n * @param  {Number=0} offset\n * @return {String}\n */\n\nvar _byteToHex = [];\n\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction unparse(buf, offset) {\n  var i = offset || 0,\n      bth = _byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n}\n/**\n * Determines whether the uuid is valid, converting\n * it from a buffer if necessary.\n *\n * @param  {String|Buffer}  uuid\n * @param  {Number=}  version\n * @return {Boolean}\n */\n\n\nmodule.exports = function (uuid, version) {\n  var parsedUuid; // If the uuid is a biffer, parse it...\n\n  if (Buffer.isBuffer(uuid)) {\n    parsedUuid = unparse(uuid);\n  } // If it's a string, it's already good.\n  else if (Object.prototype.toString.call(uuid) === '[object String]') {\n      parsedUuid = uuid;\n    } // Otherwise, it's not valid.\n    else {\n        return false;\n      }\n\n  parsedUuid = parsedUuid.toLowerCase(); // All UUIDs fit a basic schema. Match that.\n\n  if (!pattern.test(parsedUuid)) {\n    return false;\n  } // Now extract the version...\n\n\n  if (version === undefined) {\n    version = extractVersion(parsedUuid);\n  } else if (extractVersion(parsedUuid) !== version) {\n    return false;\n  }\n\n  switch (version) {\n    // For certain versions, the checks we did up to this point are fine.\n    case 1:\n    case 2:\n      return true;\n    // For versions 3 and 4, they must specify a variant.\n\n    case 3:\n    case 4:\n    case 5:\n      return ['8', '9', 'a', 'b'].indexOf(parsedUuid.charAt(19)) !== -1;\n\n    default:\n      // We should only be able to reach this if the consumer explicitly\n      // provided an invalid version. Prior to extractVersion we check\n      // that it's 1-4 in the regex.\n      throw new Error('Invalid version provided.');\n  }\n};\n/**\n * Extracts the version from the UUID, which is (by definition) the M in\n * xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx\n *\n * @param  {String} uuid\n * @return {Number}\n */\n\n\nvar extractVersion = module.exports.version = function (uuid) {\n  return uuid.charAt(14) | 0;\n};","map":{"version":3,"sources":["/home/megamind/Downloads/FatimaAllforLifelatest/FatimaAllforLife/client/node_modules/uuid-validate/index.js"],"names":["pattern","_byteToHex","i","toString","substr","unparse","buf","offset","bth","module","exports","uuid","version","parsedUuid","Buffer","isBuffer","Object","prototype","call","toLowerCase","test","undefined","extractVersion","indexOf","charAt","Error"],"mappings":"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","sourcesContent":["// Regular expression used for basic parsing of the uuid.\nvar pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\n/**\n * Unparses a UUID buffer to a string. From node-uuid:\n * https://github.com/defunctzombie/node-uuid/blob/master/uuid.js\n *\n * Copyright (c) 2010-2012 Robert Kieffer\n * MIT License - http://opensource.org/licenses/mit-license.php\n *\n * @param  {Buffer} buf\n * @param  {Number=0} offset\n * @return {String}\n */\nvar _byteToHex = [];\nfor (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n/**\n * Determines whether the uuid is valid, converting\n * it from a buffer if necessary.\n *\n * @param  {String|Buffer}  uuid\n * @param  {Number=}  version\n * @return {Boolean}\n */\nmodule.exports = function (uuid, version) {\n    var parsedUuid;\n    // If the uuid is a biffer, parse it...\n    if (Buffer.isBuffer(uuid)) {\n        parsedUuid = unparse(uuid);\n    }\n    // If it's a string, it's already good.\n    else if (Object.prototype.toString.call(uuid) === '[object String]') {\n        parsedUuid = uuid;\n    }\n    // Otherwise, it's not valid.\n    else {\n        return false;\n    }\n\n    parsedUuid = parsedUuid.toLowerCase();\n\n    // All UUIDs fit a basic schema. Match that.\n    if (!pattern.test(parsedUuid)) {\n        return false;\n    }\n\n    // Now extract the version...\n    if (version === undefined) {\n        version = extractVersion(parsedUuid);\n    } else if (extractVersion(parsedUuid) !== version) {\n        return false;\n    }\n\n    switch (version) {\n        // For certain versions, the checks we did up to this point are fine.\n        case 1:\n        case 2:\n            return true;\n\n        // For versions 3 and 4, they must specify a variant.\n        case 3:\n        case 4:\n        case 5:\n            return ['8', '9', 'a', 'b'].indexOf(parsedUuid.charAt(19)) !== -1;\n\n        default:\n            // We should only be able to reach this if the consumer explicitly\n            // provided an invalid version. Prior to extractVersion we check\n            // that it's 1-4 in the regex.\n            throw new Error('Invalid version provided.');\n    }\n};\n\n/**\n * Extracts the version from the UUID, which is (by definition) the M in\n * xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx\n *\n * @param  {String} uuid\n * @return {Number}\n */\nvar extractVersion = module.exports.version = function (uuid) {\n    return uuid.charAt(14)|0;\n};\n"]},"metadata":{},"sourceType":"script"}